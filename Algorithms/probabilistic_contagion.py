# We will use a library to solve a differential equation, as solving it from scratch is out of scope for this repo

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

class SIR:
    '''
    S => Susceptible
    I => Infected
    R => Recovered
    '''

    def __init__(self):
        pass

    def d_S(self, count_S, count_I, beta):
        return - beta * count_S * count_I
    
    def d_R(self, count_I, delta):
        return delta * count_I
    
    def d_I(self, count_S, count_I, beta, delta):
        return ( beta * count_S * count_I ) - ( delta * count_I )
    
    def solver(self, t, y, beta, delta):
        count_S, count_I, count_R = y
        return [self.d_S(count_S, count_I, beta), self.d_I(count_S, count_I, beta, delta), self.d_R(count_I, delta)]
    
    def fit(self, time_range, t_eval, beta, count_S, count_I, count_R, delta):
        N = count_S + count_I + count_R

        count_S /= N
        count_I /= N
        count_R /= N

        y = [count_S, count_I, count_R]

        args = (beta, delta)

        y = [count_S, count_I, count_R]

        sol = solve_ivp(
            self.solver, time_range, y, t_eval=t_eval,
            args=(beta,delta),
            rtol=1e-8, atol=1e-10
        )

        S, I, R = sol.y

        return S, I, R


### DRIVER CODE GENERATED BY LLM


# ----------------------------
# DRIVER CODE (paste below SIR)
# ----------------------------
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import least_squares

def rel_l2_error(yhat, y):
    return np.linalg.norm(yhat - y) / (np.linalg.norm(y) + 1e-12)

def mean_deviation(yhat, y):
    return float(np.mean(np.abs(yhat - y)))

def load_owid(country: str, local_fallback_path: str = "data/owid-covid-data.csv"):
    """
    Tries to download OWID COVID CSV from GitHub Raw (often works even if other domains are blocked),
    otherwise falls back to a local CSV path.

    If both fail: download manually once and put it at local_fallback_path.
    """
    url_github_raw = "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv"

    usecols = ["location", "date", "total_cases", "population"]
    try:
        df = pd.read_csv(url_github_raw, usecols=usecols)
        source = "github_raw"
    except Exception as e1:
        print(f"[WARN] Remote download failed ({type(e1).__name__}): {e1}")
        print(f"[INFO] Falling back to local CSV: {local_fallback_path}")
        df = pd.read_csv(local_fallback_path, usecols=usecols)
        source = "local"

    df = df[df["location"] == country].copy()
    if df.empty:
        raise ValueError(f"No rows found for country='{country}'. Check spelling (e.g., 'India', 'United States').")

    df["date"] = pd.to_datetime(df["date"])
    df = df.sort_values("date").dropna(subset=["total_cases", "population"])
    return df, source

def main():
    # ----------------------------
    # CONFIG
    # ----------------------------
    country = "India"        # try: "United States", "Italy", "Brazil"
    start_cases = 200        # start fitting once total_cases >= this
    window_days = 160        # number of days to fit from that point

    # Least squares settings
    x0 = np.array([0.6, 0.2])                   # initial guess (beta, delta) per day
    bounds = ([1e-7, 1e-7], [10.0, 10.0])        # keep positive

    local_fallback_path = "data/owid-covid-data.csv"

    # ----------------------------
    # LOAD REAL-WORLD DATA
    # ----------------------------
    df, src = load_owid(country, local_fallback_path=local_fallback_path)
    print(f"[INFO] Loaded data for {country} from: {src}")
    # pick window starting at threshold
    idx = df.index[df["total_cases"] >= start_cases]
    if len(idx) == 0:
        raise ValueError(f"{country} never reaches start_cases={start_cases} in this dataset slice.")

    start_i = df.index.get_loc(idx[0])
    end_i = min(start_i + window_days, len(df))

    dfw = df.iloc[start_i:end_i].copy()

    dates = dfw["date"].to_numpy()
    C_obs = dfw["total_cases"].to_numpy(dtype=float)  # cumulative cases
    N = float(dfw["population"].iloc[-1])

    # time axis: days since threshold (0..T)
    t_eval = np.arange(len(C_obs), dtype=float)
    t_span = (float(t_eval[0]), float(t_eval[-1]))

    # ----------------------------
    # INITIAL CONDITIONS (counts)
    # SIR class normalizes internally, so passing counts is fine.
    # We fit cumulative cases using C(t) = N*(1 - S(t)).
    # ----------------------------
    C0 = max(float(C_obs[0]), 1.0)
    I0 = C0      # approximate: treat initial cumulative as initial infected
    R0 = 0.0
    S0 = N - I0 - R0
    if S0 <= 0:
        raise ValueError("S0 <= 0. Choose a smaller window or check population/cases.")

    sir = SIR()

    # ----------------------------
    # RESIDUAL FUNCTION FOR FITTING
    # Compare C_hat(t) = N*(1 - S_frac(t)) to observed total_cases
    # ----------------------------
    def residual(theta):
        beta, delta = theta
        S_frac, I_frac, R_frac = sir.fit(
            time_range=t_span,
            t_eval=t_eval,
            beta=beta,
            count_S=S0,
            count_I=I0,
            count_R=R0,
            delta=delta
        )
        C_hat = (1.0 - S_frac) * N
        return (C_hat - C_obs)

    # ----------------------------
    # FIT beta, delta
    # ----------------------------
    res = least_squares(
        residual,
        x0=x0,
        bounds=bounds,
        max_nfev=300
    )
    beta_hat, delta_hat = res.x
    print(f"[RESULT] beta={beta_hat:.6f} per day, delta={delta_hat:.6f} per day")

    # simulate with fitted parameters
    S_frac, I_frac, R_frac = sir.fit(t_span, t_eval, beta_hat, S0, I0, R0, delta_hat)
    C_hat = (1.0 - S_frac) * N

    err = rel_l2_error(C_hat, C_obs)
    md = mean_deviation(C_hat, C_obs)
    print(f"[METRICS] Relative L2 Error={err:.6f} | Mean Deviation={md:.2f}")

    # ----------------------------
    # PLOTS (like lecture)
    # ----------------------------
    # Plot 1: data vs model cumulative
    plt.figure(figsize=(11, 4), dpi=140)
    plt.scatter(t_eval, C_obs, s=18, label="Data (total_cases)")
    plt.plot(t_eval, C_hat, linewidth=2, label="SIR fit: N*(1-S(t))")
    plt.title(
        f"SIR Fit to {country} COVID Cumulative Cases\n"
        f"beta={beta_hat:.4f}, delta={delta_hat:.4f} | Error={err:.6f}, MeanDev={md:.2f}"
    )
    plt.xlabel("Time (days since threshold)")
    plt.ylabel("Cumulative cases")
    plt.legend()
    plt.tight_layout()
    plt.show()

    # Plot 2: compartments (fractions)
    plt.figure(figsize=(11, 4), dpi=140)
    plt.plot(t_eval, S_frac, label="S (fraction)")
    plt.plot(t_eval, I_frac, label="I (fraction)")
    plt.plot(t_eval, R_frac, label="R (fraction)")
    plt.title(f"SIR Compartments (fractions) | {country} | beta={beta_hat:.4f}, delta={delta_hat:.4f}")
    plt.xlabel("Time (days since threshold)")
    plt.ylabel("Fraction of population")
    plt.legend()
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()
